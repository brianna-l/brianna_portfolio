<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image-Tracked AR (MindAR + Three.js)</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #ui {
      position: fixed; left: 0; right: 0; bottom: 0;
      color: #fff; text-align: center; padding: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: linear-gradient(to top, rgba(0,0,0,.5), rgba(0,0,0,0));
      pointer-events: none;
    }
    #hint { opacity: .8; max-width: 220px; display:block; margin: 8px auto 0; }
  </style>
  <!-- MindAR + Three (UMD builds) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mind-ar/dist/mindar-image-three.prod.js"></script>
</head>
<body>
  <div id="ui">
    <div>Point your camera at the image</div>
    <img id="hint" src="assets/poster.jpg" alt="">
  </div>

  <script>
    // main IIFE to allow top-level await-like flow
    (async () => {
      // 1) Set up MindAR with Three.js
      const mindarThree = new window.MINDAR.IMAGE.MindARThree({
        container: document.body,
        imageTargetSrc: './targets.mind',
        filterMinCF: 0.0005,   // tweak tracking stability if needed
        filterBeta:  0.01
      });

      const {renderer, scene, camera} = mindarThree;

      // 2) Lighting
      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(0, 1, 1);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      // 3) Create an anchor bound to the first target (index 0)
      const anchor = mindarThree.addAnchor(0);

      // 4) Build your floating effect
      const container = new THREE.Group();

      // 4a) A glowing sphere ~2 cm radius
      const sphereGeo = new THREE.SphereGeometry(0.02, 32, 32);
      const sphereMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0xffffff,
        emissiveIntensity: 0.6,
        metalness: 0.1,
        roughness: 0.2
      });
      const sphere = new THREE.Mesh(sphereGeo, sphereMat);
      sphere.position.set(0, 0.02, 0); // 2 cm above target center
      container.add(sphere);

      // 4b) Orbiting “particles” (billboards) — simple, performant
      const particleCount = 80;
      const particles = new THREE.Group();
      for (let i = 0; i < particleCount; i++) {
        const pGeo = new THREE.PlaneGeometry(0.006, 0.006);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.85 });
        const p = new THREE.Mesh(pGeo, pMat);
        // random ring around sphere, radius ~3–5 cm
        const r = 0.03 + Math.random() * 0.02;
        const theta = Math.random() * Math.PI * 2;
        p.position.set(Math.cos(theta) * r, 0.02 + (Math.random()*0.015-0.007), Math.sin(theta) * r);
        p.lookAt(0, 0.02, 0);
        particles.add(p);
      }
      container.add(particles);

      // 4c) Soft “light plate” close to marker (nice feedback)
      const plateGeo = new THREE.PlaneGeometry(0.08, 0.08);
      const plateMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
      const plate = new THREE.Mesh(plateGeo, plateMat);
      plate.rotation.x = -Math.PI/2;
      plate.position.set(0, 0.005, 0);
      container.add(plate);

      anchor.group.add(container);

      // 5) Simple animations
      let t = 0;
      function animateParticles(dt) {
        t += dt;
        particles.rotation.y += dt * 0.6;     // orbit
        sphere.position.y = 0.02 + Math.sin(t*1.2) * 0.007; // gentle hover
      }

      // 6) Show/hide the hint UI based on tracking
      anchor.onTargetFound = () => document.getElementById('ui').style.display = 'none';
      anchor.onTargetLost  = () => document.getElementById('ui').style.display = '';

      // 7) Start AR
      await mindarThree.start(); // asks for camera permission; starts the video+tracking

      // 8) Render loop
      const clock = new THREE.Clock();
      renderer.setAnimationLoop(() => {
        const dt = clock.getDelta();
        animateParticles(dt);
        renderer.render(scene, camera);
      });
    })();
  </script>
</body>
</html>
